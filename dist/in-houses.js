/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "./src/Galorants_In-Houses_script.js":
/*!*******************************************!*\
  !*** ./src/Galorants_In-Houses_script.js ***!
  \*******************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

eval("const TeamBalanceModule = __webpack_require__(/*! ../src/TeamBalance.js */ \"./src/TeamBalance.js\")\n\n/** @OnlyCurrentDoc */\nlet DEFAULT_TIME_SLOTS = [];\nlet TIME_SLOTS = getTimeSlots();\nlet GAME_DAY = getGameDay();\nconst TIME_SLOTS_COLUMN = 5;\nconst TEAM_SIZE = 5;\n\n/***** UI FUNCTIONS *****/\n\n/**\n * Starting point\n * See Google Workspace Scripts reference\n */\nfunction onOpen() {\n  var ui = SpreadsheetApp.getUi();\n  ui.createMenu('SCRIPTS') //creates a menu called SCRIPTS as a tab in the Google sheet\n    .addSubMenu(ui.createMenu('EU') //creates a menu with the options shown below\n      .addItem('Manage Time Slots', 'manageEUTimeSlots')\n      .addItem('Balance Teams and Players', 'sortEUPlayersIntoBalancedTeams')\n      .addItem('Clear Responses', 'clearEUResponses')\n    )\n    .addSubMenu(ui.createMenu('NA') //creates a menu with the options shown below\n      .addItem('Manage Time Slots', 'manageNATimeSlots')\n      .addItem('Balance Teams and Players', 'sortNAPlayersIntoBalancedTeams')\n    )\n    .addItem('Clear Responses', 'clearResponses') //clears Google Form responses\n    .addToUi();\n}\n\n/** \n * Wrapper for setting default time slots to prevent script duplication\n */\nfunction setDefaultTimeSlots(region) {\n  if (region == 'NA') {\n    DEFAULT_TIME_SLOTS = [\"7pm CEST/8pm WEST\", \"8pm CEST/9pm WEST\"];\n  } else if (region == 'EU') {\n    DEFAULT_TIME_SLOTS = [\"6pm PST/9pm EST\", \"7pm PST/10pm EST\"];\n  } else { //default value if for some reason the function call is invalid, should never reach this point but it's here in case\n    DEFAULT_TIME_SLOTS = [\"12pm GMT\", \"1pm GMT\"];\n  }\n}\n\n/**\n * Wrapper for managing time slots from the EU submenu\n * Includes setting default times for EU\n */\nfunction manageEUTimeSlots() {\n  setDefaultTimeSlots('EU');\n  manageTimeSlots();\n}\n\n/**\n * Wrapper for balancing the teams from the EU submenu\n * Includes setting default times for EU\n */\nfunction sortEUPlayersIntoBalancedTeams() {\n  setDefaultTimeSlots('EU');\n  sortPlayersIntoBalancedTeams();\n}\n\n/**\n * Wrapper for managing time slots from the NA submenu\n * Includes setting default times for NA\n */\nfunction manageNATimeSlots() {\n    setDefaultTimeSlots('NA');\n    manageTimeSlots();\n}\n\n/**\n * Wrapper for balancing the teams from the NA submenu\n * Includes setting default times for NA\n */\nfunction sortNAPlayersIntoBalancedTeams() {\n    setDefaultTimeSlots('NA');\n    sortPlayersIntoBalancedTeams();\n}\n\nfunction getTimeSlots() {\n  const scriptProperties = PropertiesService.getScriptProperties();\n  const storedTimeSlots = scriptProperties.getProperty('TIME_SLOTS');\n  return storedTimeSlots ? JSON.parse(storedTimeSlots) : DEFAULT_TIME_SLOTS;\n}\n\n/**\n * Changes the time slots from the default values to the new time slots as set by the user (or parsed from the sheet)\n * TODO: validation/sanitization of input (is it a valid time slot, will the input cause an error, is it dangerous to use/run, etc)\n * @param {array} newTimeSlots time slots that will be used for creating teams\n */\nfunction setTimeSlots(newTimeSlots) {\n  const scriptProperties = PropertiesService.getScriptProperties();\n  scriptProperties.setProperty('TIME_SLOTS', JSON.stringify(newTimeSlots));\n}\n\nfunction getGameDay() {\n  const scriptProperties = PropertiesService.getScriptProperties();\n  return scriptProperties.getProperty('GAME_DAY') || \"Saturday\"; // Default to Saturday if not set\n}\n\nfunction setGameDay(newGameDay) {\n  const scriptProperties = PropertiesService.getScriptProperties();\n  scriptProperties.setProperty('GAME_DAY', newGameDay);\n}\n\n/**\n * Creates a UI for managing the timeslots using UI prompts\n */\nfunction manageTimeSlots() {\n  const ui = SpreadsheetApp.getUi();\n  const result = ui.prompt(\n    'Manage Time Slots and Game Day', //title\n    `Current settings:\\n` + //start prompt\n    `Game Day: ${GAME_DAY}\\n` +\n    `Time Slots: ${TIME_SLOTS.join(\", \")}\\n\\n` +\n    'Enter your choice:\\n' +\n    '[1]: Manage Time Slots\\n' +\n    '[2]: Change Game Day\\n', //end prompt\n    ui.ButtonSet.OK_CANCEL //buttons\n  );\n\n  if (result.getSelectedButton() == ui.Button.OK) {\n    const choice = result.getResponseText().trim().toUpperCase();\n    \n    switch (choice) {\n      case '1':\n        manageTimeSlotsMenu();\n        break;\n      case '2':\n        changeGameDay();\n        break;\n      default:\n        ui.alert('Invalid Choice', 'Please enter 1, 2, or click on Cancel.', ui.ButtonSet.OK);\n        manageTimeSlots(); // Recursive call to try again\n    }\n  } else {\n    // User clicked Cancel or closed the dialog\n    ui.alert('Cancelled', 'Settings management was cancelled. Current settings remain unchanged.', ui.ButtonSet.OK);\n  }\n}\n\n/**\n * Creates a UI for the user to choose how to manage time slots\n * They can have the script parse the time slots given in the Google form or manually enter their own time slots\n * Called from user input\n */\nfunction manageTimeSlotsMenu() {\n  const ui = SpreadsheetApp.getUi();\n  const result = ui.prompt(\n    'Manage Time Slots', //title\n    `Current Time Slots: ${TIME_SLOTS.join(\", \")}\\n\\n` + //prompt start\n    'Enter your choice:\\n' +\n    '[1]: Automatically determines the time slots from the \"Time Slots\" column (if available)\\n' +\n    '[2]: Manually input time slots\\n' +\n    '[3]: Cancel (Keep current time slots)', //prompt end\n    ui.ButtonSet.OK_CANCEL //buttons\n  );\n\n  if (result.getSelectedButton() == ui.Button.OK) {\n    const choice = result.getResponseText().trim().toUpperCase();\n    \n    switch (choice) {\n      case '1':\n        setAutomaticTimeSlots(); //parses the time slots from the Google form responses\n        break;\n      case '2':\n        manuallyInputTimeSlots(); //allows the user to enter their own set of time slots\n        break;\n      case '3':\n        ui.alert('Cancelled', 'Time slot management was cancelled. Current time slots remain unchanged.', ui.ButtonSet.OK);\n        break;\n      default:\n        ui.alert('Invalid Choice', 'Please enter 1, 2, or 3.', ui.ButtonSet.OK);\n        manageTimeSlotsMenu(); // Recursive call to try again\n    }\n  } else {\n    // User clicked Cancel or closed the dialog\n    ui.alert('Cancelled', 'Time slot management was cancelled. Current time slots remain unchanged.', ui.ButtonSet.OK);\n  }\n}\n\nfunction changeGameDay() {\n  const ui = SpreadsheetApp.getUi();\n  const result = ui.prompt(\n    'Change Game Day', //title\n    `Current Game Day: ${GAME_DAY}\\n\\n` + //prompt start\n    'Enter the new game day (e.g., \"Sunday\", \"Monday\", etc.):', //prompt end\n    ui.ButtonSet.OK_CANCEL //buttons\n  );\n\n  if (result.getSelectedButton() == ui.Button.OK) {\n    const newGameDay = result.getResponseText().trim();\n    if (newGameDay) {\n      setGameDay(newGameDay);\n      GAME_DAY = newGameDay; // Update the current script's variable\n      ui.alert('Game Day Updated', `Game day has been set to: ${GAME_DAY}`, ui.ButtonSet.OK);\n    } else {\n      ui.alert('No Input', 'No game day was entered. Keeping the current game day.', ui.ButtonSet.OK);\n    }\n  } else {\n    ui.alert('Cancelled', 'Game day change was cancelled. Current game day remains unchanged.', ui.ButtonSet.OK);\n  }\n}\n\n/**\n * Allows the user to change the timeslots using values that they manually provide\n * Called from user input\n */\nfunction manuallyInputTimeSlots() {\n  const ui = SpreadsheetApp.getUi();\n  const result = ui.prompt(\n    'Set Custom Time Slots',\n    'Please enter time slots separated by commas (e.g., \"6pm PST/9pm EST, 7pm PST/10pm EST\"):',\n    ui.ButtonSet.OK_CANCEL);\n\n  const button = result.getSelectedButton();\n  const text = result.getResponseText();\n  \n  if (button == ui.Button.OK) {\n    if (text) {\n      const newTimeSlots = text.split(',').map(slot => slot.trim());\n      setTimeSlots(newTimeSlots); // Store the new time slots\n      TIME_SLOTS = newTimeSlots; // Update the current script's variable\n      ui.alert('Time Slots Set', `Time slots have been set to: ${TIME_SLOTS.join(\", \")}`, ui.ButtonSet.OK);\n    } else {\n      ui.alert('No Input', 'No time slots were entered. Using current time slots.', ui.ButtonSet.OK);\n    }\n  } else if (button == ui.Button.CANCEL) {\n    ui.alert('Cancelled', 'Manual time slot setting was cancelled. Using current time slots.', ui.ButtonSet.OK);\n  }\n}\n\n/**\n * Parses the available time slots from the Google Form responses and sets the script's\n * time slots to use those values.\n * Called from user input.\n */\nfunction setAutomaticTimeSlots() {\n  const ui = SpreadsheetApp.getUi();\n  const ss = SpreadsheetApp.getActiveSpreadsheet();\n  const sheet = ss.getSheets()[0]; // Get the first sheet\n  \n  // Get time slots from the 5th column\n  const timeSlotsRange = sheet.getRange(2, TIME_SLOTS_COLUMN, sheet.getLastRow() - 1, 1);\n  const timeSlotValues = timeSlotsRange.getValues().flat().filter(Boolean);\n  \n  // Split any combined time slots\n  const splitTimeSlots = timeSlotValues.flatMap(slot => slot.split(',').map(s => s.trim()));\n  \n  // Use Set to remove duplicates, then convert back to array\n  const uniqueTimeSlots = [...new Set(splitTimeSlots)];\n  \n  if (uniqueTimeSlots.length > 0) {\n    setTimeSlots(uniqueTimeSlots); // Store the new time slots\n    TIME_SLOTS = uniqueTimeSlots; // Update the current script's variable\n    const message = `Time slots have been set to: ${TIME_SLOTS.join(\", \")}`;\n    ui.alert('Time Slots Updated', message, ui.ButtonSet.OK);\n  } else {\n    ui.alert('No Time Slots Found', 'No time slots were found in the \"Time Slots\" column. Using current time slots.', ui.ButtonSet.OK);\n  }\n}\n\nfunction sortPlayersIntoBalancedTeams() {\n  Logger.log(\"sortPlayersIntoBalancedTeams function started\");\n\n  // Update Time and Day variables\n  TIME_SLOTS = getTimeSlots(); // Refresh TIME_SLOTS at the start of the function\n  GAME_DAY = getGameDay(); // Refresh GAME_DAY at the start of the function\n\n  try {\n    const ss = SpreadsheetApp.getActiveSpreadsheet();\n    const playersSheet = ss.getSheets()[0];\n    const teamsSheet = ss.getSheetByName(\"Teams\") || ss.insertSheet(\"Teams\");\n\n    Logger.log(\"Sheets retrieved successfully\");\n    \n    const allPlayers = getPlayersData(playersSheet);\n    Logger.log(\"All players data retrieved: \" + JSON.stringify(allPlayers));\n    \n    if (allPlayers.length === 0) {\n      throw new Error(\"No valid players found. Please check the player data.\");\n    }\n    \n    const teamsAndSubs = TeamBalanceModule.createOptimalTeams(allPlayers);\n    Logger.log(\"Teams and substitutes created: \" + JSON.stringify(teamsAndSubs));\n    \n    writeTeamsToSheet(teamsSheet, teamsAndSubs);\n    Logger.log(\"Teams written to sheet\");\n    \n    const discordPings = createDiscordPings(teamsAndSubs.teams, teamsAndSubs.substitutes);\n  \n    // Write Discord pings to a new sheet\n    const discordPingsSheet = ss.getSheetByName(\"Discord Pings\") || ss.insertSheet(\"Discord Pings\");\n    writeDiscordPingsToSheet(discordPingsSheet, discordPings);\n    Logger.log(\"Discord Pings completed\");\n    \n  } catch (e) {\n    Logger.log(`Error: ${e.message}`);\n    throw e;\n  }\n  \n  Logger.log(\"sortPlayersIntoBalancedTeams function completed\");\n}\n\nfunction getPlayersData(sheet) {\n  const data = sheet.getDataRange().getValues();\n  Logger.log(`Raw data: ${JSON.stringify(data.slice(0, 2))}`);\n\n  if (data.length < 2) {\n    Logger.log(\"Not enough data in the sheet. Make sure there's at least one player entry.\");\n    return [];\n  }\n\n  const players = data.slice(1).map((row, index) => {\n    const player = {\n      timestamp: row[0],\n      discordUsername: row[1],\n      riotID: row[2],\n      pronouns: row[3],\n      timeSlots: row[TIME_SLOTS_COLUMN - 1] ? row[TIME_SLOTS_COLUMN - 1].toString().split(',').map(s => s.trim()) : TIME_SLOTS,\n      multipleGames: row[5],\n      substitute: row[6].toString().toLowerCase() === 'yes',\n      lobbyHost: row[7],\n      duo: row[8],\n      currentRank: getRankValue(row[9]),\n      peakRank: getRankValue(row[10]),\n    };\n    player.averageRank = (player.currentRank + player.peakRank) / 2;\n\n    Logger.log(`Player ${index + 1}: Discord: ${player.discordUsername}, Current Rank: ${row[9]} (${player.currentRank}), Peak Rank: ${row[10]} (${player.peakRank}), Substitute: ${player.substitute}, Time Slots: ${player.timeSlots}`);\n\n    return player;\n  });\n\n  const validPlayers = players.filter(player => {\n    const isValid = player.currentRank > 0 || player.peakRank > 0;\n    if (!isValid) {\n      Logger.log(`Filtered out player: ${player.discordUsername} (Current Rank: ${player.currentRank}, Peak Rank: ${player.peakRank})`);\n    }\n    return isValid;\n  });\n\n  Logger.log(`Number of players before filtering: ${players.length}`);\n  Logger.log(`Number of players after filtering: ${validPlayers.length}`);\n  Logger.log(`Sample player data: ${JSON.stringify(validPlayers[0])}`);\n\n  return validPlayers;\n}\n\n\nfunction writeTeamsToSheet(sheet, teamsAndSubs) {\n  sheet.clear();\n  let rowIndex = 0;\n  const teamColors = [\"#FFF2CC\", \"#D9EAD3\", \"#C9DAF8\", \"#F4CCCC\", \"#FFD966\", \"#B6D7A8\", \"#9FC5E8\", \"#EA9999\"];\n  const headerColor = \"#4A86E8\";\n  const subHeaderColor = \"#A4C2F4\";\n\n  TIME_SLOTS.forEach((timeSlot, slotIndex) => {\n    // Write time slot header\n    sheet.getRange(rowIndex + 1, 1, 1, 6).merge()\n      .setValue(timeSlot)\n      .setFontWeight(\"bold\")\n      .setBackground(headerColor)\n      .setFontColor(\"#ffffff\")\n      .setFontSize(14)\n      .setHorizontalAlignment(\"center\");\n    rowIndex++;\n\n    const timeSlotTeams = teamsAndSubs.teams.filter(team => team.timeSlot === timeSlot);\n\n    timeSlotTeams.forEach((team, teamIndex) => {\n      const teamColor = teamColors[(slotIndex * 4 + teamIndex) % teamColors.length];\n      \n      // Write team header\n      sheet.getRange(rowIndex + 1, 1, 1, 5).merge()\n        .setValue(team.name)\n        .setFontWeight(\"bold\")\n        .setBackground(teamColor)\n        .setFontColor(\"#000000\")\n        .setFontSize(12)\n        .setHorizontalAlignment(\"center\");\n      \n      // Add Team Total in the same row\n      const totalCell = sheet.getRange(rowIndex + 1, 6);\n      totalCell.setFontWeight(\"bold\")\n        .setBackground(teamColor)\n        .setFontColor(\"#000000\")\n        .setFontSize(12)\n        .setHorizontalAlignment(\"right\");\n      \n      // Add formula for team total using column and row references\n      const startRow = rowIndex + 3;\n      const endRow = startRow + TEAM_SIZE - 1;\n      const totalFormula = `SUM($F${startRow}:$F${endRow})`;\n      totalCell.setFormula(`\"Total: \" & TEXT(${totalFormula}, \"0.0\")`);\n      \n      rowIndex++;\n\n      // Write player header\n      const headerRange = sheet.getRange(rowIndex + 1, 1, 1, 6);\n      headerRange.setValues([[\"Discord\", \"Riot ID\", \"Current Rank\", \"Peak Rank\", \"Lobby Host\", \"Avg Rank\"]])\n        .setFontWeight(\"bold\")\n        .setBackground(teamColor)\n        .setFontColor(\"#000000\")\n        .setHorizontalAlignment(\"center\");\n      rowIndex++;\n\n      // Write player data\n      team.players.forEach(player => {\n        const playerRow = [\n          player.discordUsername,\n          player.riotID,\n          getRankName(player.currentRank),\n          getRankName(player.peakRank),\n          player.lobbyHost,\n          player.averageRank.toFixed(2)\n        ];\n        const range = sheet.getRange(rowIndex + 1, 1, 1, playerRow.length);\n        range.setValues([playerRow]).setBackground(teamColor);\n        \n        // Set alignment\n        range.setHorizontalAlignment(\"center\").setVerticalAlignment(\"middle\");\n        range.setVerticalAlignment(\"middle\");\n        range.setBorder(true, true, true, true, true, true, \"#000000\", SpreadsheetApp.BorderStyle.SOLID);\n\n        setConditionalFormatting(range.offset(0, 2, 1, 2)); // Apply conditional formatting to Current Rank and Peak Rank\n        rowIndex++;\n      });\n      \n      rowIndex++; // Add an empty row between teams\n    });\n\n    // Write substitutes for this time slot\n    const substitutes = teamsAndSubs.substitutes[timeSlot];\n    if (substitutes && substitutes.length > 0) {\n      // Write substitutes header\n      sheet.getRange(rowIndex + 1, 1, 1, 6).merge()\n        .setValue(`Substitutes`)\n        .setFontWeight(\"bold\")\n        .setBackground(subHeaderColor)\n        .setFontColor(\"#000000\")\n        .setFontSize(12)\n        .setHorizontalAlignment(\"center\");\n      rowIndex++;\n\n      // Write substitutes column headers\n      const subHeaderRange = sheet.getRange(rowIndex + 1, 1, 1, 6);\n      subHeaderRange.setValues([[\"Discord\", \"Riot ID\", \"Current Rank\", \"Peak Rank\", \"Lobby Host\", \"Avg Rank\"]])\n        .setFontWeight(\"bold\")\n        .setBackground(subHeaderColor)\n        .setFontColor(\"#000000\")\n        .setHorizontalAlignment(\"center\");\n      rowIndex++;\n\n      // Write substitute player data\n      substitutes.forEach(sub => {\n        const subRow = [\n          sub.discordUsername,\n          sub.riotID,\n          getRankName(sub.currentRank),\n          getRankName(sub.peakRank),\n          sub.lobbyHost,\n          sub.averageRank.toFixed(2)\n        ];\n        const range = sheet.getRange(rowIndex + 1, 1, 1, subRow.length);\n        range.setValues([subRow]).setBackground(\"#F3F3F3\");\n        \n        // Set alignment\n        range.setHorizontalAlignment(\"center\").setVerticalAlignment(\"middle\");\n        range.setVerticalAlignment(\"middle\");\n        range.setBorder(true, true, true, true, true, true, \"#000000\", SpreadsheetApp.BorderStyle.SOLID);\n\n        setConditionalFormatting(range.offset(0, 2, 1, 2)); // Apply conditional formatting to Current Rank and Peak Rank\n        rowIndex++;\n      });\n\n      rowIndex++; // Add an empty row after substitutes\n    }\n\n    rowIndex += 2; // Add some space before the next time slot\n  });\n\n  // Adjust column widths\n  sheet.autoResizeColumns(1, 6);\n  sheet.setColumnWidth(1, 150); // Set Discord column width\n  sheet.setColumnWidth(2, 150); // Set Riot ID column width\n  sheet.setColumnWidth(6, 100); // Set Avg Rank column width\n  sheet.setFrozenRows(1);\n}\n\nfunction createDiscordPings(teams, substitutes) {\n  const currentDate = new Date();\n  const nextGameDay = new Date(currentDate.setDate(currentDate.getDate() + ((7 + ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'].indexOf(GAME_DAY) - currentDate.getDay()) % 7)));\n  const formattedDate = nextGameDay.toLocaleDateString('en-US', { month: 'long', day: 'numeric' });\n  \n  let pings = `# Here are the teams for ${GAME_DAY}, ${formattedDate}!\\n\\n`;\n  \n  TIME_SLOTS.forEach((timeSlot, slotIndex) => {\n    const timeSlotTeams = teams.filter(team => team.timeSlot === timeSlot);\n    const timeSlotSubstitutes = substitutes[timeSlot] || [];\n    \n    if (timeSlotTeams.length > 0 || timeSlotSubstitutes.length > 0) {\n      pings += `## TIMESLOT ${slotIndex + 1}\\n\\n`;\n      \n      for (let i = 0; i < timeSlotTeams.length; i += 2) {\n        const twoTeams = timeSlotTeams.slice(i, i + 2);\n        const lobbyHost = twoTeams.flatMap(team => team.players).find(player => player.lobbyHost === \"Yes\");\n        if (lobbyHost) {\n          if (timeSlotTeams.length > 2) {\n            pings += `### LOBBY HOST **Team ${i + 1} & ${i + 2}**\\n@${lobbyHost.discordUsername}\\n\\n`;\n          } else {\n            pings += `### LOBBY HOST\\n@${lobbyHost.discordUsername}\\n\\n`;\n          }\n        }\n        \n        twoTeams.forEach((team, index) => {\n          pings += `### Team ${i + index + 1}\\n`;\n          team.players.forEach(player => {\n            pings += `@${player.discordUsername}\\n`;\n          });\n          pings += \"\\n\";\n        });\n      }\n      \n      if (timeSlotSubstitutes.length > 0) {\n        pings += \"### Substitutes\\n\";\n        timeSlotSubstitutes.forEach(sub => {\n          pings += `@${sub.discordUsername}\\n`;\n        });\n        pings += \"\\n\";\n      }\n    }\n  });\n  \n  return pings;\n}\n\nfunction writeDiscordPingsToSheet(sheet, pings) {\n  sheet.clear();\n  \n  const lines = pings.split(\"\\n\");\n  const numRows = lines.length;\n  const range = sheet.getRange(1, 1, numRows, 1);\n  \n  // Set values and basic formatting\n  range.setValues(lines.map(line => [line]));\n  range.setWrapStrategy(SpreadsheetApp.WrapStrategy.WRAP);\n  range.setVerticalAlignment(\"top\");\n  \n  // Apply formatting based on line content\n  for (let i = 0; i < numRows; i++) {\n    const cell = range.getCell(i + 1, 1);\n    const content = lines[i];\n    \n    if (content.startsWith(\"# Here are the teams\")) {\n      // First line (title)\n      cell.setFontWeight(\"bold\").setFontSize(18).setBackground(\"#4A86E8\").setFontColor(\"#ffffff\");\n    } else if (content.startsWith(\"##\")) {\n      // Time slot headers\n      cell.setFontWeight(\"bold\").setFontSize(14).setBackground(\"#4A86E8\").setFontColor(\"#ffffff\");\n    } else if (content.startsWith(\"### LOBBY HOST\")) {\n      // Lobby host headers\n      cell.setFontWeight(\"bold\").setFontSize(13).setBackground(\"#CFE2F3\");\n    } else if (content.startsWith(\"### Team\")) {\n      // Team headers\n      cell.setFontWeight(\"bold\").setFontSize(13).setBackground(\"#CFE2F3\");\n    } else if (content.startsWith(\"### Substitutes\")) {\n      // Substitutes header\n      cell.setFontWeight(\"bold\").setFontSize(13).setBackground(\"#CFE2F3\");\n    } else if (content.startsWith(\"@\")) {\n      // Player names\n      cell.setFontSize(11).setValue(\"  \" + content); // Add two spaces for indentation\n    } else if (content.trim() === \"\") {\n      // Empty lines\n      cell.setValue(\"\"); // Clear the cell content\n    }\n    \n    // Adjust row height\n    sheet.setRowHeight(i + 1, 21);\n  }\n  \n  sheet.autoResizeColumns(1, 1);\n  sheet.setColumnWidth(1, Math.max(sheet.getColumnWidth(1), 300)); // Ensure minimum width\n}\n\nfunction setConditionalFormatting(range) {\n  const rules = [\n    {rank: \"Iron\", color: \"#464646\"},\n    {rank: \"Bronze\", color: \"#a6824c\"},\n    {rank: \"Silver\", color: \"#dce1dc\"},\n    {rank: \"Gold\", color: \"#dc8e21\"},\n    {rank: \"Platinum\", color: \"#27697a\"},\n    {rank: \"Diamond\", color: \"#c688f7\"},\n    {rank: \"Ascendant\", color: \"#40b57e\"},\n    {rank: \"Immortal\", color: \"#953640\"},\n    {rank: \"Radiant\", color: \"#f2dc95\"}\n  ];\n  \n  const conditionalFormatRules = rules.map(rule => \n    SpreadsheetApp.newConditionalFormatRule()\n      .setRanges([range])\n      .whenTextContains(rule.rank)\n      .setBackground(rule.color)\n      .setFontColor(getContrastColor(rule.color))\n      .build()\n  );\n  \n  range.getSheet().setConditionalFormatRules(\n    range.getSheet().getConditionalFormatRules().concat(conditionalFormatRules)\n  );\n}\n\nfunction getContrastColor(hexcolor) {\n  const r = parseInt(hexcolor.substr(1,2), 16);\n  const g = parseInt(hexcolor.substr(3,2), 16);\n  const b = parseInt(hexcolor.substr(5,2), 16);\n  \n  const luminance = (0.299 * r + 0.587 * g + 0.114 * b) / 255;\n  \n  return luminance > 0.5 ? \"#000000\" : \"#ffffff\";\n}\n\nfunction getRankValue(rank) {\n  const ranks = {\n    \"Iron 1\": 1, \"Iron 2\": 5, \"Iron 3\": 10,\n    \"Bronze 1\": 15, \"Bronze 2\": 20, \"Bronze 3\": 25,\n    \"Silver 1\": 35, \"Silver 2\": 40, \"Silver 3\": 45,\n    \"Gold 1\": 55, \"Gold 2\": 60, \"Gold 3\": 65,\n    \"Platinum 1\": 75, \"Platinum 2\": 80, \"Platinum 3\": 85,\n    \"Diamond 1\": 95, \"Diamond 2\": 100, \"Diamond 3\": 110,\n    \"Ascendant 1\": 125, \"Ascendant 2\": 130, \"Ascendant 3\": 140,\n    \"Immortal 1\": 160, \"Immortal 2\": 165, \"Immortal 3\": 180,\n    \"Radiant\": 220\n  };\n  return ranks[rank] || 0;\n}\n\n\nfunction getRankName(rankValue) {\n  const rankNames = {\n    1: \"Iron 1\", 5: \"Iron 2\", 10: \"Iron 3\",\n    15: \"Bronze 1\", 20: \"Bronze 2\", 25: \"Bronze 3\",\n    35: \"Silver 1\", 40: \"Silver 2\", 45: \"Silver 3\",\n    55: \"Gold 1\", 60: \"Gold 2\", 65: \"Gold 3\",\n    75: \"Platinum 1\", 80: \"Platinum 2\", 85: \"Platinum 3\",\n    95: \"Diamond 1\", 100: \"Diamond 2\", 110: \"Diamond 3\",\n    125: \"Ascendant 1\", 130: \"Ascendant 2\", 140: \"Ascendant 3\",\n    160: \"Immortal 1\", 165: \"Immortal 2\", 180: \"Immortal 3\",\n    220: \"Radiant\"\n  };\n  return rankNames[rankValue] || \"Unranked\";\n}\n\n\nfunction clearResponses() {\n  // Get the active spreadsheet\n  var ss = SpreadsheetApp.getActiveSpreadsheet();\n  \n  // Get the UI\n  var ui = SpreadsheetApp.getUi();\n\n  // Get the first sheet\n  var sheet = ss.getSheets()[0];\n  \n  // Get the number of rows in the sheet\n  var lastRow = sheet.getLastRow();\n  \n  // Check if there are any rows to delete\n  if (lastRow > 1) {\n    // Show a confirmation dialog\n    var response = ui.alert('Confirm Deletion', 'Are you sure you want to clear all responses? This action cannot be undone.', ui.ButtonSet.YES_NO);\n\n    // If the user clicks \"Yes\", proceed with deletion\n    if (response == ui.Button.YES) {\n      // Delete all rows below the header\n      sheet.deleteRows(2, lastRow - 1);\n      \n      // Log the action\n      Logger.log(\"Cleared all responses from the Forms Responses sheet.\");\n      \n      // Show a confirmation message\n      ui.alert('Success', 'All responses have been cleared.', ui.ButtonSet.OK);\n    } else {\n      // If the user clicks \"No\", log that the operation was cancelled\n      Logger.log(\"Clear responses operation cancelled by user.\");\n    }\n  } else {\n    // If there are no responses to clear, inform the user\n    ui.alert('No Responses', 'There are no responses to clear.', ui.ButtonSet.OK);\n  }\n}\n\n\n//# sourceURL=webpack://galorants-in-houses/./src/Galorants_In-Houses_script.js?");

/***/ }),

/***/ "./src/TeamBalance.js":
/*!****************************!*\
  !*** ./src/TeamBalance.js ***!
  \****************************/
/***/ ((module) => {

eval("//here for testing jest, remove when first real jest test is done\nfunction sum(a, b) {\n  return a + b;\n}\n\nfunction createOptimalTeams(players) {\n  let result = {\n    teams: [],\n    substitutes: {}\n  };\n  let assignedPlayers = new Set();\n\n  TIME_SLOTS.forEach(timeSlot => {\n    let timeSlotPlayers = players.filter(p => p.timeSlots.includes(timeSlot));\n    \n    let { teams, substitutes, assignedPlayers: newAssignedPlayers } = createOptimalTeamsForTimeSlot(timeSlotPlayers, timeSlot, assignedPlayers);\n    \n    result.teams = result.teams.concat(teams);\n    result.substitutes[timeSlot] = substitutes;\n    assignedPlayers = newAssignedPlayers;\n  });\n\n  return result;\n}\n\nfunction createOptimalTeamsForTimeSlot(players, timeSlot, assignedPlayers) {\n  const numPlayers = players.length;\n  const numTeams = Math.floor(numPlayers / TEAM_SIZE);\n  \n  // Ensure even number of teams\n  const adjustedNumTeams = numTeams % 2 === 0 ? numTeams : numTeams - 1;\n  \n  let teams = [];\n  \n  // Initialize empty teams\n  for (let i = 0; i < adjustedNumTeams; i++) {\n    teams.push({\n      name: `Team ${i + 1}`,\n      timeSlot: timeSlot,\n      players: [],\n      total: 0 // total rank power of the team\n    });\n  }\n\n  // Sort players by average rank (descending)\n  const sortedPlayers = players.slice().sort((a, b) => b.averageRank - a.averageRank);\n\n  // Calculate the number of substitutes\n  const numSubstitutes = Math.max(0, numPlayers - (adjustedNumTeams * TEAM_SIZE));\n\n  // Distribute players evenly across teams and substitutes\n  let substituteIndex = 0;\n  const substitutes = [];\n  for (let i = 0; i < sortedPlayers.length; i++) {\n    const player = sortedPlayers[i];\n    if (i % (adjustedNumTeams + 1) === 0 && substitutes.length < numSubstitutes) {\n      // Add to substitutes\n      substitutes.push(player);\n    } else {\n      // Add to team\n      const teamIndex = i % teams.length;\n      teams[teamIndex].players.push(player);\n      teams[teamIndex].total += player.averageRank;\n    }\n  }\n\n  // Optimize team balance\n  for (let iteration = 0; iteration < 100; iteration++) {\n    let improved = false;\n    for (let i = 0; i < teams.length; i++) {\n      for (let j = i + 1; j < teams.length; j++) {\n        if (trySwapPlayers(teams[i], teams[j])) {\n          improved = true;\n        }\n      }\n    }\n    if (!improved) break;\n  }\n\n  // Calculate team spread for logging\n  const teamSpread = getTeamSpread(teams);\n  Logger.log(`Team spread for ${timeSlot}: ${teamSpread.toFixed(2)}`);\n\n  return {\n    teams,\n    substitutes,\n    assignedPlayers: new Set([...assignedPlayers, ...teams.flatMap(team => team.players.map(p => p.discordUsername))])\n  };\n}\n\nfunction trySwapPlayers(team1, team2) {\n  for (let i = 0; i < team1.players.length; i++) {\n    for (let j = 0; j < team2.players.length; j++) {\n      const diff1 = team1.players[i].averageRank - team2.players[j].averageRank;\n      const newTotal1 = team1.total - diff1;\n      const newTotal2 = team2.total + diff1;\n\n      if (Math.abs(newTotal1 - newTotal2) < Math.abs(team1.total - team2.total)) {\n        // Swap players\n        const temp = team1.players[i];\n        team1.players[i] = team2.players[j];\n        team2.players[j] = temp;\n\n        // Update totals\n        team1.total = newTotal1;\n        team2.total = newTotal2;\n\n        return true;\n      }\n    }\n  }\n  return false;\n}\n\nfunction getTeamSpread(teams) {\n  const totals = teams.map(team => team.total);\n  return Math.max(...totals) - Math.min(...totals);\n}\n\nmodule.exports = {\n  sum: sum,\n  createOptimalTeams: createOptimalTeams,\n  createOptimalTeamsForTimeSlot: createOptimalTeamsForTimeSlot,\n  trySwapPlayers: trySwapPlayers,\n  getTeamSpread: getTeamSpread\n}\n\n\n\n//# sourceURL=webpack://galorants-in-houses/./src/TeamBalance.js?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval devtool is used.
/******/ 	var __webpack_exports__ = __webpack_require__("./src/Galorants_In-Houses_script.js");
/******/ 	
/******/ })()
;